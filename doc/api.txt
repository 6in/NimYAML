===
API
===

Overview
========

NimYAML advocates parsing YAML input into native Nim types. Basic Nim library
types like integers, floats and strings, as well as all tuples, enums and
objects without private fields are supported out-of-the-box. Reference types are
also supported, and NimYAML is able to detect if a reference occurs more than
once and will serialize it accordingly. This means that NimYAML is able to dump
and load potentially cyclic objects.

While loading into and dumping from native Nim types is the preferred way to use
NimYAML, it also gives you complete control over each processing step, so that
you can for example only use the parser and process its event stream yourself.
The following diagram gives an overview of NimYAML's features based on the YAML
processing pipeline. The items and terminology YAML defines is shown in
*italic*, NimYAML's implementation name is shown in **bold**.

.. image:: processing.svg

Intermediate Representation
===========================

The base of all YAML processing with NimYAML is the
`YamlStream <yaml.html#YamlStream>`_. This is basically an iterator over
`YamlStreamEvent <yaml.html#YamlStreamEvent>`_ objects. Every proc that
represents a single stage of the loading or dumping process will either take a
``YamlStream`` as input or return a ``YamlStream``. Procs that implement the
whole process in one step hide the ``YamlStream`` from the user. Every proc that
returns a ``YamlStream`` guarantees that this stream is well-formed according to
the YAML specification.

This stream-oriented API can efficiently be used to parse large amounts of data.
The drawback is that errors in the input are only discovered while processing
the ``YamlStream``. If the ``YamlStream`` encounters an exception while
producing the next event, it will throw a ``YamlStreamError`` which contains the
original exception as ``parent``. The caller should know which exceptions are
possible as parents of ``YamlStream`` because they know the source of the
``YamlStream`` they provided.

Loading YAML
============

If you want to load YAML character data directly into a native Nim variable, you
can use `load <yaml.html#load,Stream,K>`_. This is the easiest and recommended
way to load YAML data. The following paragraphs will explain the steps involved.

For parsing, a `YamlParser <yaml.html#YamlParser>`_ object is needed. This
object stores some state while parsing that may be useful for error reporting to
the user. The
`parse <yaml.html#present,YamlStream,Stream,TagLibrary,PresentationStyle,int>`_
proc implements the YAML processing step of the same name. All syntax errors in
the input character stream are processed by ``parse``, which will raise a
``YamlParserError`` if it encounters a syntax error.

Transforming a ``YamlStream`` to a native YAML object is done via
``construct``. It skips the ``compose`` step for efficiency reasons. As Nim is
statically typed, you have to know the target type when you write your loading
code. This is different from YAML APIs of dynamically typed languages. If you
cannot know the type of your YAML input at compile time, you have to manually
process the ``YamlStream`` to serve your needs.

Dumping YAML
============

Dumping is preferredly done with
`dump <yaml.html#dump,K,Stream,PresentationStyle,TagStyle,AnchorStyle,int>`_,
which serializes a native Nim variable to a character stream. Like ``load``, you
can use the steps involved separately.

You transform a variable into a ``YamlStream`` with
`represent <yaml.html#represent,T,TagStyle,AnchorStyle>`_. Depending on the
``AnchorStyle`` you specify, this will transform ``ref`` variables with multiple
instances into anchored elements and aliases (for ``asTidy`` and ``asAlways``)
or write the same element into all places it occurs (for ``asNone``). Be aware
that if you use ``asNone``, the value you serialize might not round-trip.

Transforming a ``YamlStream`` into YAML character data is done with
`present <yaml.html#present,YamlStream,Stream,TagLibrary,PresentationStyle,int>`_.
You can choose from multiple presentation styles. ``psJson`` is not able to
process some features of ``YamlStream``s, the other styles support all features
and are guaranteed to round-trip to the same ``YamlStream`` if you parse the
generated YAML character stream again.
